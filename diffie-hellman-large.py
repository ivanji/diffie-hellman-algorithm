# Python representation of Diffie-Hellman Key Exchange (D-H) method.
# The implementation requires large primes. (At least 1024-bit)
# (Simplified using small prime numbers).
#
# RFC sets specific Security considerations for the resulting key
# Resulting Modulus must be at least 1024-bit in size.
# https://tools.ietf.org/html/rfc3526

# Step 1: Two prime numbers are generated and shared with the other party

import random
import math
import sys

def rabinMiller(n):
     s = n-1
     t = 0
     while s&1 == 0:
         s = s/2
         t +=1
     k = 0
     while k<128:
         a = random.randrange(2,n-1)
         #a^s is computationally infeasible.  we need a more intelligent approach
         #v = (a**s)%n
         #python's core math module can do modular exponentiation
         v = pow(a,s,n) #where values are (num,exp,mod)
         if v != 1:
             i=0
             while v != (n-1):
                 if i == t-1:
                     return False
                 else:
                     i = i+1
                     v = (v**2)%n
         k+=2
     return True

def isPrime(n):
     #lowPrimes is all primes (sans 2, which is covered by the bitwise and operator)
     #under 1000. taking n modulo each lowPrime allows us to remove a huge chunk
     #of composite numbers from our potential pool without resorting to Rabin-Miller
     lowPrimes =   [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97
                   ,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179
                   ,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269
                   ,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367
                   ,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461
                   ,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571
                   ,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661
                   ,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773
                   ,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883
                   ,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]
     if (n >= 3):
         if (n&1 != 0):
             for p in lowPrimes:
                 if (n == p):
                    return True
                 if (n % p == 0):
                     return False
             return rabinMiller(n)
     return False

def generateLargePrime(k):
     #k is the desired bit length
     r=100*(math.log(k,2)+1) #number of attempts max
     r_ = r
     while r>0:
        #randrange is mersenne twister and is completely deterministic
        #unusable for serious crypto purposes
         n = random.randrange(2**(k-1),2**(k))
         r-=1
         if isPrime(n) == True:
             return n
     return "Failure after "+`r_` + " tries."

# Step 1: Two prime numbers are generated and shared with the other party
sharedBase = generateLargePrime(256) # g
sharedPrime = generateLargePrime(2048) # p

print sharedPrime

# print "g is equal to %s & p is equal to %s" % (sharedBase, sharedPrime) 

print "--------------------------"
# Step 2: A Secret is generated by each of the parties

aliceSecret = 6 # a
bobSecret = 2 # b

print "--------------------------"
# Step 3: The following Trapdoor function is performed by both parties using the available details. Results from each is exchanged by the parties.

print "Alice performs the following operation: g^a mod p and sends result (A) to Bob"
                          
A = (sharedBase**aliceSecret) % sharedPrime
print "--------------------------"

print "Bob performs same operation and sends result (B) to Alice"

B = (sharedBase**bobSecret) % sharedPrime

print "--------------------------"
# Step 4: Same Trapdoor function is performed by both parties. The resulting number will be the same and this will become their private key
print "Alice now performs same operation using calculated result (B) from Bob"

aliceModulo = (B**aliceSecret) % sharedPrime

print "--------------------------"

print "Bob now performs same operation using calculated result (A) from Alice"

bobModulo = (A**bobSecret) % sharedPrime

print bobModulo
print aliceModulo
print "--------------------------"

print "Shared Key is equal to %s." % bobModulo